// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/jizambrana5/dota2-hero-picker/internal/pkg/domain"
	"sync"
)

// StorageMock is a mock implementation of hero.Storage.
//
//	func TestSomethingThatUsesStorage(t *testing.T) {
//
//		// make and configure a mocked hero.Storage
//		mockedStorage := &StorageMock{
//			GetAllHeroesFunc: func(ctx context.Context) ([]domain.Hero, error) {
//				panic("mock out the GetAllHeroes method")
//			},
//			GetHeroFunc: func(ctx context.Context, id string) (domain.Hero, error) {
//				panic("mock out the GetHero method")
//			},
//			SaveHeroFunc: func(ctx context.Context, hero domain.Hero) error {
//				panic("mock out the SaveHero method")
//			},
//		}
//
//		// use mockedStorage in code that requires hero.Storage
//		// and then make assertions.
//
//	}
type StorageMock struct {
	// GetAllHeroesFunc mocks the GetAllHeroes method.
	GetAllHeroesFunc func(ctx context.Context) ([]domain.Hero, error)

	// GetHeroFunc mocks the GetHero method.
	GetHeroFunc func(ctx context.Context, id string) (domain.Hero, error)

	// SaveHeroFunc mocks the SaveHero method.
	SaveHeroFunc func(ctx context.Context, hero domain.Hero) error

	// calls tracks calls to the methods.
	calls struct {
		// GetAllHeroes holds details about calls to the GetAllHeroes method.
		GetAllHeroes []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetHero holds details about calls to the GetHero method.
		GetHero []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// SaveHero holds details about calls to the SaveHero method.
		SaveHero []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hero is the hero argument value.
			Hero domain.Hero
		}
	}
	lockGetAllHeroes sync.RWMutex
	lockGetHero      sync.RWMutex
	lockSaveHero     sync.RWMutex
}

// GetAllHeroes calls GetAllHeroesFunc.
func (mock *StorageMock) GetAllHeroes(ctx context.Context) ([]domain.Hero, error) {
	if mock.GetAllHeroesFunc == nil {
		panic("StorageMock.GetAllHeroesFunc: method is nil but Storage.GetAllHeroes was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAllHeroes.Lock()
	mock.calls.GetAllHeroes = append(mock.calls.GetAllHeroes, callInfo)
	mock.lockGetAllHeroes.Unlock()
	return mock.GetAllHeroesFunc(ctx)
}

// GetAllHeroesCalls gets all the calls that were made to GetAllHeroes.
// Check the length with:
//
//	len(mockedStorage.GetAllHeroesCalls())
func (mock *StorageMock) GetAllHeroesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAllHeroes.RLock()
	calls = mock.calls.GetAllHeroes
	mock.lockGetAllHeroes.RUnlock()
	return calls
}

// GetHero calls GetHeroFunc.
func (mock *StorageMock) GetHero(ctx context.Context, id string) (domain.Hero, error) {
	if mock.GetHeroFunc == nil {
		panic("StorageMock.GetHeroFunc: method is nil but Storage.GetHero was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetHero.Lock()
	mock.calls.GetHero = append(mock.calls.GetHero, callInfo)
	mock.lockGetHero.Unlock()
	return mock.GetHeroFunc(ctx, id)
}

// GetHeroCalls gets all the calls that were made to GetHero.
// Check the length with:
//
//	len(mockedStorage.GetHeroCalls())
func (mock *StorageMock) GetHeroCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGetHero.RLock()
	calls = mock.calls.GetHero
	mock.lockGetHero.RUnlock()
	return calls
}

// SaveHero calls SaveHeroFunc.
func (mock *StorageMock) SaveHero(ctx context.Context, hero domain.Hero) error {
	if mock.SaveHeroFunc == nil {
		panic("StorageMock.SaveHeroFunc: method is nil but Storage.SaveHero was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hero domain.Hero
	}{
		Ctx:  ctx,
		Hero: hero,
	}
	mock.lockSaveHero.Lock()
	mock.calls.SaveHero = append(mock.calls.SaveHero, callInfo)
	mock.lockSaveHero.Unlock()
	return mock.SaveHeroFunc(ctx, hero)
}

// SaveHeroCalls gets all the calls that were made to SaveHero.
// Check the length with:
//
//	len(mockedStorage.SaveHeroCalls())
func (mock *StorageMock) SaveHeroCalls() []struct {
	Ctx  context.Context
	Hero domain.Hero
} {
	var calls []struct {
		Ctx  context.Context
		Hero domain.Hero
	}
	mock.lockSaveHero.RLock()
	calls = mock.calls.SaveHero
	mock.lockSaveHero.RUnlock()
	return calls
}

// DatasetMock is a mock implementation of hero.Dataset.
//
//	func TestSomethingThatUsesDataset(t *testing.T) {
//
//		// make and configure a mocked hero.Dataset
//		mockedDataset := &DatasetMock{
//			GetRecordsFunc: func(ctx context.Context) ([][]string, error) {
//				panic("mock out the GetRecords method")
//			},
//		}
//
//		// use mockedDataset in code that requires hero.Dataset
//		// and then make assertions.
//
//	}
type DatasetMock struct {
	// GetRecordsFunc mocks the GetRecords method.
	GetRecordsFunc func(ctx context.Context) ([][]string, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetRecords holds details about calls to the GetRecords method.
		GetRecords []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockGetRecords sync.RWMutex
}

// GetRecords calls GetRecordsFunc.
func (mock *DatasetMock) GetRecords(ctx context.Context) ([][]string, error) {
	if mock.GetRecordsFunc == nil {
		panic("DatasetMock.GetRecordsFunc: method is nil but Dataset.GetRecords was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetRecords.Lock()
	mock.calls.GetRecords = append(mock.calls.GetRecords, callInfo)
	mock.lockGetRecords.Unlock()
	return mock.GetRecordsFunc(ctx)
}

// GetRecordsCalls gets all the calls that were made to GetRecords.
// Check the length with:
//
//	len(mockedDataset.GetRecordsCalls())
func (mock *DatasetMock) GetRecordsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetRecords.RLock()
	calls = mock.calls.GetRecords
	mock.lockGetRecords.RUnlock()
	return calls
}

// BenchmarkMock is a mock implementation of hero.Benchmark.
//
//	func TestSomethingThatUsesBenchmark(t *testing.T) {
//
//		// make and configure a mocked hero.Benchmark
//		mockedBenchmark := &BenchmarkMock{
//			GetHeroBenchmarkFunc: func(ctx context.Context, id string) (interface{}, error) {
//				panic("mock out the GetHeroBenchmark method")
//			},
//		}
//
//		// use mockedBenchmark in code that requires hero.Benchmark
//		// and then make assertions.
//
//	}
type BenchmarkMock struct {
	// GetHeroBenchmarkFunc mocks the GetHeroBenchmark method.
	GetHeroBenchmarkFunc func(ctx context.Context, id string) (interface{}, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetHeroBenchmark holds details about calls to the GetHeroBenchmark method.
		GetHeroBenchmark []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
	}
	lockGetHeroBenchmark sync.RWMutex
}

// GetHeroBenchmark calls GetHeroBenchmarkFunc.
func (mock *BenchmarkMock) GetHeroBenchmark(ctx context.Context, id string) (interface{}, error) {
	if mock.GetHeroBenchmarkFunc == nil {
		panic("BenchmarkMock.GetHeroBenchmarkFunc: method is nil but Benchmark.GetHeroBenchmark was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetHeroBenchmark.Lock()
	mock.calls.GetHeroBenchmark = append(mock.calls.GetHeroBenchmark, callInfo)
	mock.lockGetHeroBenchmark.Unlock()
	return mock.GetHeroBenchmarkFunc(ctx, id)
}

// GetHeroBenchmarkCalls gets all the calls that were made to GetHeroBenchmark.
// Check the length with:
//
//	len(mockedBenchmark.GetHeroBenchmarkCalls())
func (mock *BenchmarkMock) GetHeroBenchmarkCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGetHeroBenchmark.RLock()
	calls = mock.calls.GetHeroBenchmark
	mock.lockGetHeroBenchmark.RUnlock()
	return calls
}
