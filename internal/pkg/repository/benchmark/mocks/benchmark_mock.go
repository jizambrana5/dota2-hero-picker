// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/gojek/heimdall/v7"
	"io"
	"net/http"
	"sync"
)

// RequesterMock is a mock implementation of benchmark.Requester.
//
//	func TestSomethingThatUsesRequester(t *testing.T) {
//
//		// make and configure a mocked benchmark.Requester
//		mockedRequester := &RequesterMock{
//			AddPluginFunc: func(p heimdall.Plugin)  {
//				panic("mock out the AddPlugin method")
//			},
//			DeleteFunc: func(url string, headers http.Header) (*http.Response, error) {
//				panic("mock out the Delete method")
//			},
//			DoFunc: func(req *http.Request) (*http.Response, error) {
//				panic("mock out the Do method")
//			},
//			GetFunc: func(url string, headers http.Header) (*http.Response, error) {
//				panic("mock out the Get method")
//			},
//			PatchFunc: func(url string, body io.Reader, headers http.Header) (*http.Response, error) {
//				panic("mock out the Patch method")
//			},
//			PostFunc: func(url string, body io.Reader, headers http.Header) (*http.Response, error) {
//				panic("mock out the Post method")
//			},
//			PutFunc: func(url string, body io.Reader, headers http.Header) (*http.Response, error) {
//				panic("mock out the Put method")
//			},
//		}
//
//		// use mockedRequester in code that requires benchmark.Requester
//		// and then make assertions.
//
//	}
type RequesterMock struct {
	// AddPluginFunc mocks the AddPlugin method.
	AddPluginFunc func(p heimdall.Plugin)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(url string, headers http.Header) (*http.Response, error)

	// DoFunc mocks the Do method.
	DoFunc func(req *http.Request) (*http.Response, error)

	// GetFunc mocks the Get method.
	GetFunc func(url string, headers http.Header) (*http.Response, error)

	// PatchFunc mocks the Patch method.
	PatchFunc func(url string, body io.Reader, headers http.Header) (*http.Response, error)

	// PostFunc mocks the Post method.
	PostFunc func(url string, body io.Reader, headers http.Header) (*http.Response, error)

	// PutFunc mocks the Put method.
	PutFunc func(url string, body io.Reader, headers http.Header) (*http.Response, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddPlugin holds details about calls to the AddPlugin method.
		AddPlugin []struct {
			// P is the p argument value.
			P heimdall.Plugin
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// URL is the url argument value.
			URL string
			// Headers is the headers argument value.
			Headers http.Header
		}
		// Do holds details about calls to the Do method.
		Do []struct {
			// Req is the req argument value.
			Req *http.Request
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// URL is the url argument value.
			URL string
			// Headers is the headers argument value.
			Headers http.Header
		}
		// Patch holds details about calls to the Patch method.
		Patch []struct {
			// URL is the url argument value.
			URL string
			// Body is the body argument value.
			Body io.Reader
			// Headers is the headers argument value.
			Headers http.Header
		}
		// Post holds details about calls to the Post method.
		Post []struct {
			// URL is the url argument value.
			URL string
			// Body is the body argument value.
			Body io.Reader
			// Headers is the headers argument value.
			Headers http.Header
		}
		// Put holds details about calls to the Put method.
		Put []struct {
			// URL is the url argument value.
			URL string
			// Body is the body argument value.
			Body io.Reader
			// Headers is the headers argument value.
			Headers http.Header
		}
	}
	lockAddPlugin sync.RWMutex
	lockDelete    sync.RWMutex
	lockDo        sync.RWMutex
	lockGet       sync.RWMutex
	lockPatch     sync.RWMutex
	lockPost      sync.RWMutex
	lockPut       sync.RWMutex
}

// AddPlugin calls AddPluginFunc.
func (mock *RequesterMock) AddPlugin(p heimdall.Plugin) {
	if mock.AddPluginFunc == nil {
		panic("RequesterMock.AddPluginFunc: method is nil but Requester.AddPlugin was just called")
	}
	callInfo := struct {
		P heimdall.Plugin
	}{
		P: p,
	}
	mock.lockAddPlugin.Lock()
	mock.calls.AddPlugin = append(mock.calls.AddPlugin, callInfo)
	mock.lockAddPlugin.Unlock()
	mock.AddPluginFunc(p)
}

// AddPluginCalls gets all the calls that were made to AddPlugin.
// Check the length with:
//
//	len(mockedRequester.AddPluginCalls())
func (mock *RequesterMock) AddPluginCalls() []struct {
	P heimdall.Plugin
} {
	var calls []struct {
		P heimdall.Plugin
	}
	mock.lockAddPlugin.RLock()
	calls = mock.calls.AddPlugin
	mock.lockAddPlugin.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *RequesterMock) Delete(url string, headers http.Header) (*http.Response, error) {
	if mock.DeleteFunc == nil {
		panic("RequesterMock.DeleteFunc: method is nil but Requester.Delete was just called")
	}
	callInfo := struct {
		URL     string
		Headers http.Header
	}{
		URL:     url,
		Headers: headers,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(url, headers)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedRequester.DeleteCalls())
func (mock *RequesterMock) DeleteCalls() []struct {
	URL     string
	Headers http.Header
} {
	var calls []struct {
		URL     string
		Headers http.Header
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Do calls DoFunc.
func (mock *RequesterMock) Do(req *http.Request) (*http.Response, error) {
	if mock.DoFunc == nil {
		panic("RequesterMock.DoFunc: method is nil but Requester.Do was just called")
	}
	callInfo := struct {
		Req *http.Request
	}{
		Req: req,
	}
	mock.lockDo.Lock()
	mock.calls.Do = append(mock.calls.Do, callInfo)
	mock.lockDo.Unlock()
	return mock.DoFunc(req)
}

// DoCalls gets all the calls that were made to Do.
// Check the length with:
//
//	len(mockedRequester.DoCalls())
func (mock *RequesterMock) DoCalls() []struct {
	Req *http.Request
} {
	var calls []struct {
		Req *http.Request
	}
	mock.lockDo.RLock()
	calls = mock.calls.Do
	mock.lockDo.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *RequesterMock) Get(url string, headers http.Header) (*http.Response, error) {
	if mock.GetFunc == nil {
		panic("RequesterMock.GetFunc: method is nil but Requester.Get was just called")
	}
	callInfo := struct {
		URL     string
		Headers http.Header
	}{
		URL:     url,
		Headers: headers,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(url, headers)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequester.GetCalls())
func (mock *RequesterMock) GetCalls() []struct {
	URL     string
	Headers http.Header
} {
	var calls []struct {
		URL     string
		Headers http.Header
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// Patch calls PatchFunc.
func (mock *RequesterMock) Patch(url string, body io.Reader, headers http.Header) (*http.Response, error) {
	if mock.PatchFunc == nil {
		panic("RequesterMock.PatchFunc: method is nil but Requester.Patch was just called")
	}
	callInfo := struct {
		URL     string
		Body    io.Reader
		Headers http.Header
	}{
		URL:     url,
		Body:    body,
		Headers: headers,
	}
	mock.lockPatch.Lock()
	mock.calls.Patch = append(mock.calls.Patch, callInfo)
	mock.lockPatch.Unlock()
	return mock.PatchFunc(url, body, headers)
}

// PatchCalls gets all the calls that were made to Patch.
// Check the length with:
//
//	len(mockedRequester.PatchCalls())
func (mock *RequesterMock) PatchCalls() []struct {
	URL     string
	Body    io.Reader
	Headers http.Header
} {
	var calls []struct {
		URL     string
		Body    io.Reader
		Headers http.Header
	}
	mock.lockPatch.RLock()
	calls = mock.calls.Patch
	mock.lockPatch.RUnlock()
	return calls
}

// Post calls PostFunc.
func (mock *RequesterMock) Post(url string, body io.Reader, headers http.Header) (*http.Response, error) {
	if mock.PostFunc == nil {
		panic("RequesterMock.PostFunc: method is nil but Requester.Post was just called")
	}
	callInfo := struct {
		URL     string
		Body    io.Reader
		Headers http.Header
	}{
		URL:     url,
		Body:    body,
		Headers: headers,
	}
	mock.lockPost.Lock()
	mock.calls.Post = append(mock.calls.Post, callInfo)
	mock.lockPost.Unlock()
	return mock.PostFunc(url, body, headers)
}

// PostCalls gets all the calls that were made to Post.
// Check the length with:
//
//	len(mockedRequester.PostCalls())
func (mock *RequesterMock) PostCalls() []struct {
	URL     string
	Body    io.Reader
	Headers http.Header
} {
	var calls []struct {
		URL     string
		Body    io.Reader
		Headers http.Header
	}
	mock.lockPost.RLock()
	calls = mock.calls.Post
	mock.lockPost.RUnlock()
	return calls
}

// Put calls PutFunc.
func (mock *RequesterMock) Put(url string, body io.Reader, headers http.Header) (*http.Response, error) {
	if mock.PutFunc == nil {
		panic("RequesterMock.PutFunc: method is nil but Requester.Put was just called")
	}
	callInfo := struct {
		URL     string
		Body    io.Reader
		Headers http.Header
	}{
		URL:     url,
		Body:    body,
		Headers: headers,
	}
	mock.lockPut.Lock()
	mock.calls.Put = append(mock.calls.Put, callInfo)
	mock.lockPut.Unlock()
	return mock.PutFunc(url, body, headers)
}

// PutCalls gets all the calls that were made to Put.
// Check the length with:
//
//	len(mockedRequester.PutCalls())
func (mock *RequesterMock) PutCalls() []struct {
	URL     string
	Body    io.Reader
	Headers http.Header
} {
	var calls []struct {
		URL     string
		Body    io.Reader
		Headers http.Header
	}
	mock.lockPut.RLock()
	calls = mock.calls.Put
	mock.lockPut.RUnlock()
	return calls
}
